type SievedInteger = (Integer, (Integer, Integer))

sieveSundaram :: Integer -> [Integer]
sieveSundaram = map toPrime . filter isSundaram . sieve
  where toPrime (n, _)= (n*2) + 1

isSundaram :: SievedInteger -> Bool
isSundaram (n, (i, j)) = n /= (2 * i * j + i + j)

sieve :: Integer -> [SievedInteger]
sieve n = zip [1..n] [(i, j) | i <- [1..], j <- [1..10]]

-- exclude v, if v == 2ij + i + j
-- should exclude
-- 1 + 1 + 2*1*1 = 4
-- 1 + 2 + 2*1*2 = 7
-- 1 + 3 + 2*1*3 = 10
-- 1 + 4 + 2*1*4 = 13
-- ...
-- 2 + 1 + 2*2*1 = 7
-- 2 + 2 + 2*2*2 = 12
-- 2 + 3 + 2*2*3 = 17
-- ... and so on
--
-- 
-- indexes (ij)
-- value. __ - removed number
-- 00 01 02 03 04 05 06 07 08 09
-- 01 02 03 __ 05 06 __ 08 09 __
--
-- 10 11 12 13 14 15 16 17 18 19
-- 11 12 __ 14 15 __ 17 18 __ 20
--
-- 20 21 22 23 24 25 26 27 28 29
-- 21 __ 23 24 __ 26 27 __ 29 30
--
-- 30 31 32 33 34 35 36 37 38 39
-- __ 32 33 __ 35 36 __ 38 39 __
--
-- 40 41 42 43 44 45 46 47 48 49
-- 41 42 __ 44 45 __ 47 48 __ 50
--
-- 50 51 52 53 54 55 56 57 58 59
-- 51 __ 53 54 __ 56 57 __ 59 60
--
-- 60 61 62 63 64 65 66 67 68 69
-- __ 62 63 __ 65 66 __ 68 69 __
--
-- 70 71 72 73 74 75 76 77 78 79
-- 71 72 __ 74 75 __ 77 78 __ 80
--
-- 80 81 82 83 84 85 86 87 88 89
-- 81 __ 83 84 __ 86 87 __ 89 90
--
-- 90 91 92 93 94 95 96 97 98 99
-- __ 92 93 __ 95 96 __ 98 99 100
--
